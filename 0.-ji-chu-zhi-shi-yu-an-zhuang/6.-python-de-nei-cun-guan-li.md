# 6. Python的内存管理

**建议：完成基础语法的学习后再看** 

内存是每一个程序都要打交道的地方，不同于C类语言的手工管理，Python是一门动态的面向对象的解释型语言，对象与引用是分离的。内存也是由解释器动态管理的。 Python中对于对象的赋值操作就是一个创建对象与引用的过程。在第一章我们提到的赋值语句`a=1`就是将`1`这个对象与`a`引用了起来。

## 查看内存地址

Python中有一个内置函数`id()`，就是用来返回一个对象的内存地址的。而利用`hex()`，我们就能看到实际的十六位内存地址。 例如：

```python
a = 1

print(id(a))
print(hex(id(a)))
```

## 引用计数

在Python中，一切皆对象，为了提升效率，在一定情况下，一个对象会被引用多次。  
引用计数就是计算一个对象被引用了多少次的一个量化的表示。

### 引用计数的增加

* 赋值语句
* 实参传参

  **引用计数的减少**

* 函数运行结束
* 当用`del()`删除某个引用时
* 如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少。

  **引用计数的查看**

  我们可以使用`sys`模块中的`getrefcount()`，来查看某个对象的引用计数。

  需要注意的是，当使用某个引用作为参数，传递给`getrefcount()`时，参数实际上创建了一个临时的引用。因此，getrefcount\(\)所得到的结果，会比期望的多1。

  **特殊点**

  -5到256的这些数字，Python中默认会创建对象来优化，所以会提前缓存好，在使用过程中直接引用就可以了。但是超过这个范围，只有在同一代码块中出现才会有相同的内存地址。短字符串也会在创建之后会被引用多次。

  > ```python
  > a = 0
  > b = 0
  > id(a) == id(b)
  > ```
  >
  > True
  >
  > ```python
  > a = -5
  > b = -5
  > id(a) == id(b)
  > ```
  >
  > True
  >
  > ```python
  > a = -6
  > b = -6
  > id(a) == id(b)
  > ```
  >
  > False
  >
  > ```python
  > a = 256
  > b = 256
  > id(a) == id(b)
  > ```
  >
  > True
  >
  > ```python
  > a = 257
  > b = 257
  > id(a) == id(b)
  > ```
  >
  > False
  >
  > ```python
  > a = -1.0
  > b = -1.0
  > id(a) == id(b)
  > ```
  >
  > False

## 对象间的引用

Python的一个容器对象，比如列表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。列表中如果引用列表，可能会有意想不到的问题。参见copy模块​。 容器对象的引用可能构成很复杂的拓扑结构，因此在刚开始的阶段不建议进行容器对象的引用。  
两个对象可能相互引用，从而构成所谓的引用环\(reference cycle\)。

```python
a = []
b = [a]
a.append(b)
```

即使是一个对象，只需要自己引用自己，也能构成引用环。

```python
a = []
a.append(a)
print(sys.getrefcount(a))
```

引用环会给垃圾回收机制带来很大的麻烦。

## 垃圾回收

Python中，拥有一种管理内存的机制，就是垃圾回收。从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。这时候我们称之为标记清除。  
但是一个对象的引用计数减为零之后不会被立即清理掉，Python只会在特定条件下启动垃圾回收。当Python运行时，会记录其中分配对象\(object allocation\)和取消分配对象\(object deallocation\)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。

我们可以通过gc模块的get\_threshold\(\)方法，查看该阈值:

```python
import gc
print(gc.get_threshold())
```

当然，我们也可以手动启动垃圾回收，即使用`gc.collect()`来进行垃圾回收。但由于频繁的垃圾回收具有效率问题，因此需要考虑是否需要进行后再操作。

### 分代回收

Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

## 参考

* [https://www.cnblogs.com/vamei/p/3232088.html](https://www.cnblogs.com/vamei/p/3232088.html)

